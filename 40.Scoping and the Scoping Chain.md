## 40. Scoping and the Scope Chain
  So in this scope we have access the variable "a" and also to the first function. In orange, we have the scope of the first function which defines the variable "b" and the second function, and this is the local scope, not a global scope. And do you remember what I said about lexical scoping in the last slide? Thanks to lexical scope, this scope has also access to its parent's scope and all the variables functions that it defines. And in this case, that's global scope. Finally, in the green, the scope of the second function. In there we have a "console.log" statement which attemps to print the values of variable "a","b" and "c". <br>
  Now, the variables are not defined in that function. Only "c", but as we already know, a scope has access to the scope of the function in which is sits lexically, so we running this code, the JavaScript engine will not find variable "b" in the current scope. So it just goes up and looks in the scope of its parent's function and says "oh, here is b. So let's use that." And the same happens for variable "a". It does not find it in the current scope and also not in the parent scope. So it goes even more up all the way to the global scope and this is excatly called the "scope chain". Only if the JavaScript engine does not find a variable anywhere it throws an error and stops execution.<br>
  Now, it's very important to note that this does not work backwards. For example, the global scope will never ever have accessed to the variables "b" or "c" unless we return the values from the functions. So locally scoped variables are not visible to their parent's scopes. This is why I put the red arrow pointing upwards. Because that's the only direction the scope chain works.<br>
  Now how does this actually work behind the scenes? Remember the execution context object that we had been talking about before? In the creation phase, each execution context object will get exact scope chain which is basically all the variable objects that an execution context has access to. Because, remember the variable object is what stores all the defined variables and functions. So in this example, in the second scope, we have access to the variable object of the second functions, of the first function and to global variable object.<br>
  So why does this work? This works because, of course, the scoping chain and in this case thanks to the scoping chain,the second function has access to the variables of the first function and of the global scope. That's because the second function is written inside of the first, which in turn, is written inside of the global scope. That's why we call it lexcial scoping. So another extremely important concept and very much used in practice as well.<br>
  <br>
  ...So we saw it at the scope chain for each execution context is stored in the execution context object. But I just wanted to make very clear that the execution stack is different from scope chain. So here we see another simple code example, and we already know how the execution stack works. So the first function gets called, which then calls the second function which in turn calls the third function and for each of these calls, a new execution context is put on top the execution stack. Now, for the scope chain, things are a bit different. We see that the global scope contains the "a" variable as well as the first and third functions. Then the scope of the first function contains the second function, and this is how I like to represent it. Now let's remember that the execution stack is the order in which functions are called. But the scope chain is the order in which the functions are written in the code where they are lexically in our code. So the order in which functions are called does not determine the scope of the variables within these functions. What determines the scope of variables is where the functions are written. Since the third function is not in the scope of the second function, of course it cannot access variables "b" and "c" defined in the second and first functions. It can only access the global variable "a", because the function is written in the global scope. So, it's execution contexts that store the scope chain of each function in the variable object, but they do not have an effect on the scope chain itself. This is important to understand.<br>
  So we have, in the global scope, the "var a" which is defined as "hello", we have the first function here and we have the third function all in the global scope, or in the global execution context.Then inside of the first function, we have the "b" variable, we have the second function call, and the function declaration. We already know that because of hoising we can call the function before it's written here. Okay, then in the third function, we just defined the varialbe "d" and attempt to console log the variable "c".<br>
  So two things here. The first thing is why can the second function even call the third function? So the third function was called from the second function. And this, once again, is possible because of scoping. The second function has accessed to third function because of the scope chain. So the second function has access to the global scape out here, in which the third function also sits lexically. So the second function has the ability to call the third function because of the scope chain and there's nothing new. Now the second thing is why do we actually get this error saying that "c" is not defined, even though it was the second function who called third function? The second function is the function that defined the "c" variable and then called the third function, but still the third function cannot access variable "c" which it is trying to print here, which as we see result in this error. Obviouly that the third function cannot access variable "c" because the execution stack is different from the scope chain. To answer this question, who can access the "c" variable the order in which the functions were called does not matter. All that matters is that the third function is in a different scope than the second function and so it can not access variable "c". So which variables can the third function actually access? It's variable "a" and "d". So these are the only variables that we have access to because they are in the scope chain for the third function.