# 206 Prototype

Now it's time to finally start using prototypes. And we're gonna talk about prototypes. So actually, we talked about prototypes,prototypal inheritance and delegation earlier already. But how does all of that actually work? Well, it can be summarized like this. So, first each and every function in JavaScript automatically has a property called prototype. And that includes, of course, constructor functions.

Now every object that's created by a certain constructor function will get access to all the methods and properties that we define on the constructors prototype property. So just to visualize in our case, this would be "person.prototype". So the prototype property of the constructor function. So again, as I was just saying, all the objects that are created through this constructor function here will inherit, so they will get access to all the methods and properties that are defined on this prototype property. And so let's no actually add a method to this prototype property.So, this is actually an object. And so we can now say "calcAge" and then we can simply set it to this same function here, so equal, and that's it.

And then let's actually take a look at his prototype property just for curiosity. And so here is that prototype property. You see that right now we already have the "calcAge" method in there. So before it was kind of an empty object. Basically it was empty before but now there is the "calcAge" method already in here,so this one that we just defined down here.

Alright. Once again, remember how I said that each object created by this constructor function will now get access to all the methods of this prototype property. So of course, also to "calcAge". And so we should be able to do this. So "jonas", which is this object here which was of course created by this constructor function.

So we can now use this method here on the "Jonas" object even though it is not really on the object itself, right? So if we check our Jonas here, then you see that it contains of course the "birthyear" and the "firstname", but it does not contain the "calcAge" method. But still, we have access to it because of prototypal inheritance. 

So that effectively solves this problem that we had before when we added the "calcAge" method directly to each of the objects. So here we would have created a copy of this method here and attached it to every single object. And so that's why we don't do this. Instead, what we do is this. Because now there exists only one copy of this function. So only one of them exists, but then all of the objects that are created using this constructor function can basically reuse this function on themselves. And so, the "this" keyword, in each of them is as always set to the object that is calling the method. So just like we learned previously,the "this" keyword is set to the object that is calling the method. So, in a nutshell, this is how we implement very basic prototypal inheritance in JavaScript and practice. So we just observed, that the Jonas and the Matilda objects are kind of somehow connected to the person, right? That's why they can have access to these methods or in this case to just this method that is located inside the prototype property of person. But how and why does this actually work? Well, it works because any object always has access to the methods and properties from its prototype. And the prototype of Jonas and Matilda is "person.prototype". And we can actually confirm that because each object has a special property called a "\__proto__".So like this. And so this is the prototype of Jonas. It's not the prototype property but it is simply the prototype. And so here again, we see the "calcAge" function and that's why Jonas is able to use this. So to prototype of the Jonas object is essentially the prototype property of the constructor function.  But what I just said sounded incredibly confusing, didn't it? So shouldn't "person.prototype" be the prototype of "Person",I mean should this prototype property here not be the prototype of person? Well, actually, no. So this is the confusing part. So "person.prototype" here is actually not the prototype of person. But instead, it is what's gonna be used as the prototype of all the objects that are created with the person constructor function. So that's a subtle but important difference that you need to keep in mind. In fact, what I just said that is confirmed by this comparison that we just did here. So we just saw that Jonas's prototype which is this, is the prototype property of the person constructor function. And there are actually other built in method that we can use to prove this. So on any object, for example, "object.prototype", we can test if this is a prototype of another object. So we can call "isPrototypeOf" and then Jonas. And so this should also become true. And indeed it is. So this confirms one more time that person dot prototype is indeed the prototype of Jonas. But "person.prototype" is not the prototype of person. So you see, it is false here. 

`console.log(Person.prototype.isPrototypeOf(Person))   --false`

This very common confusion comes from bad naming of this property. So the fact that it's called prototype kind of implies that this is the prototype of person, but as we just learned, it is actually not. Probably shouldn't be called prototype but instead something like prototype of linked objects or something like this. So if this makes it easier you can think of the prototype property as prototype of linked objects property. Even though of course it's not called like this, but this would be a more honest name. So take some time to really understand what the prototype of what object actually is here.

Now, anyway, where does this proto property here, on the Jonas object actually come from? Well, remember the new operator that we talked about before, well, it contains this step number three which links the empty new object to the prototype. And so basically, it will create this proto property. So it creates this proto property and it sets its value to the prototype property of the function that is being called. So again, it sets the proto property on the object to the prototype property of the constructor function. And so this is how JavaScript knows internally that the Jonas object is connected to "person.prototype". And in fact, when we check out the Jonas object here we can indeed also see that property in here. So it's also right here and if we open that up then you see exactly "person.prototype" which contains this "calcAge" function.

So, by now you're probably sick of hearing the word prototype but I just wanted to quickly show you that we can also set properties on the prototype. So not just methods.

Now however, since when we take a look at these objects, well, as we just saw this property is not really directly in the object, so it's not its own property. So own properties are only the ones that are declared directly on the object itself. Not including the inherited properties. And actually in JavaScript, there is a way of checking for that.

"This" property is not really inside of the Jonas object. It simply has access to it because of its prototype. So because it's in the prototype property of person. And sometimes, this method here can be quite helpful in certain situations.