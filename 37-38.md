37 Execution Contexts and the Execution Stack
The last lecture was a conceptual overview about what happens in the JavaScrpit engine once we run our code, how it parsed and translated into machine code. Now let’s focus on the order in which the code is run, and for that we need to talk about execution contexts.
All Javascript code needs to run in an environment, and these environments are called execution contexts. So you can imagine an execution context like a box, or like a container which stores variables, and in which a piece of our code is evaluated and executed. We will go more in depth about this in the next slides. Now the default execution context is always the global context. Remember that I said that an execution context is where a piece of code is executed. Well, in a global context, all the code that is not inside of any funciton is executed, and this is very important. So again, the global execution context is for variables and funtions that are not inide of any function. Now, you can alos think of an execution context as an object. Remember objects from the introductory lectures? So the global execution context is associated with the global object, which in case of the browser is the window object. So everythin that we declare in the global context automatically gets attached to the window object in the browser. And it works like this: declaring a variable called “lastName” or “window.lastName” is the exact same thing. It’s like “lastName” is a property or the window object. And as we talked about in the intro lectures, properties are just variables attached to objects. So this makes sense, right? And I know this is a lot to absorb so I really encourage you to make some notes about all these things to reference them later. And of course you can also watch these lecture again when you fell more confident with your coding.
So remember the global execution context is for code that is not inside of any function. But what about code that is in functions? It’s actually very simple. Each time that we call a function, it gets its own brand-new execution context. Let me show you that by an example. So this first declaration is not in any function. So we are in a global execution context here as the red arrow down there shows on the right side. So this variable is stored in a global object. We’ll see how exactly that works in the next lecture. Next up, this function declaration is also in a global context. So we’re still here in the same execution context. And the same about the second and the third function. And this is where the function begins, because here is where we call the very first function. And as I mentioned before, a new function gets its new execution context. And what happens is that this new context is put on top of the current context, forming the so-called Execution Stack. So for the duration of this first function call, the execution context for that function becomes the active context in which the code is execcuted. Ok. So let’s get inside the first function with our arrow. So this “A” variable will now get stored in the execution context fot this function, and not anymore in the global context. Now we call the second function, and I’m sure you can guess by now what will happen, right? So once again, a new execution context will be created and put on top of the execution stack. And here we go, this is now the active context. Okay, so now variable “B” is stored and put on top of the stack, as we already know. So now, inside of the third function we just have these two variables declarations, and nothing more. So this function has now done all its work, and so we say that the function returns. So what happens to its execution context? It just gets removed from the top of the stack. Very simple. And then the context of the second function which called the third function, is back to being the active context. And we go back to the second function. So this “z” variable gets stored in the currently-active context, and after the function returns, the context also pops off the stack. So back to the first function now. And here the same thing. The function is done, it returns, and so we exit it, and the exectution context pops off the stack. And like this, we executed all three functions, created three execution contexts, and popped them off the stack when the functions returned. Now you may asked “How are all these execution contexts actually created? And why is this so important?” 


38. Execution Contexts in Detail:Creation and Execution Phases and Hoisting
Let’s start by creating a representaion of an execution context so that we can have a bit more detail about how it actually works. First of, as I mentioned in the previous lecture, we can associate an execution context with an object, which is what we have here, and this object has three properties: the variable object, which will contain function arguments in a variable declaration as well as function declarations; the scope chain, which contains the current variable objects as well as the variable objects of all its parents; and “this” variable that we have already seen in action in the introductory lecture about objects. All right, so how is execution context actually created? Let’s start with what we already know. When a function is called, a new execution context is put on top of the execution stack, and this happens in 2 phases: the creation phase and the execution phase. In the creation phase, we first have the creation of the variable object, and we will talk about that in the next slide; then, the creation of the scope chain, and this is a huge topic for itself, so we’ll talk about it in the next lecture; and lastly, the “this” variable is determined and set. So basically the properties of the execution context object that we have here on the left side are defined. Then, in the execution phase, the code and the function that generated the current execution context is run line by line, and all the variables are defined. If it’s a global context, then it’s a global code that is execute it. So let’s now look at the creation of the variable object in the creation phase. So this is what happens in the creation of the variable object. The argument object is created. which contains all the arguments that were passed into the function. The code is scanned for function declarations, and for each function a property is created in a variable object pointing to that function. This means that all the functions will be stored inside the variable object, even before the code starts executing, and this is very important for you to know. And lastly, the code is scanned for variable declarations, and for each function a property is created in a variable object and set to “undefined”, and these last two points is what we commonly call “hoisting”. Functions and variables are hoisted in JavaScript, which means that they are available before the execution phase actually starts. They are hoisted in a different way, though. The difference between functions and variables is that functions are already defined before the execution phase starts while variables are set up to “undefined” and will only be defined in the execution phase. As you remember from the last slide, the execution phase comes just after the creation phase. Now hoisting is something that confuses may new JavaScript developers, so it’s really important that you understand it right now. That’s why we’re going to write some code in the next lecture, so that we can see this in practice. So just to recap all of this once again, each execution context has an object which stores a lot of imporant data that the funtion will use while it’s running, and this happens even before the code is executed.
