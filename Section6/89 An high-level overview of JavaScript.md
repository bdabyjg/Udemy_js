# An high-level overview of 89 JavaScript

JavaScript is a **high-level**, **prototype-based object-oriented**, **multi-paradigm**, **interpreted or just-in-time compiled**, **dynamic, single-threaded, garbage-collected** programming language with **first-class functions** and a non-blocking **event loop concurrency model**.<br/>

Low-level languages, such as C where you have to manually manage these resources. For example asking the computer for memory to create a new variable. On the other side, you have high-level languages such as JavaScript and Python where we do not have to manage resource at all because these languages have so-called abstractions that take all of that work away from us. This makes the language easier to learn and to use, but the downside is that programs will never be as fast or as optimized as for example C programs. Now one of the powerful tools that takes memory management away from us developers is garbage-collection which is basically an algorithm inside the JavaScript engine which automatically removes old, unused objects from the computer memory in order not to clog it up with unnecessary stuff. So it's a little bit like JavaScript has a cleaning guy who cleans our memory from time to time so that we don't have to do it manually in our code.<br>

Next up, JavaScript is an interpreted or just-in-time compiled language. The computer's processor only understands zeros and ones. Ultimately, every single program needs to be written in zeros and ones which is also called machine code. We simply write human-readable JavaScript code which is an abstraction over machine code, but this code eventually needs to be translated to machine code. And that step can be either compiling or interpreting. This step is necessary in every single programming language because no one writes machine code manually. In the case of JavaScript, this happens inside the JavaScript engine.<br>

One of the things that makes JavaScript so popular is the fact that it's a multi-paradigm language. In programming, a paradigm is an approach and an overall mindset of structuring our code, which will ultimately direct the coding style and technique in a project that uses a certain paradigm. Now, 3 popular paradigms are: procedural, object-oriented and functional programming. So procedural programming is what we've been doing so far which is basically just organizing the code in a very linear way and then with some functions in between.  Also we can classify paradigms as imperative or declarative. Many languages are only procedural or only object-oriented or only functional, but JavaScript does all of it. So it's really flexible and versatile. We can do really whatever we want with it. We can use whatever paradigm we want. What does "prototype-based, object-oriented" mean? Well, first, everything in JavaScript is an object except for primitive values such as numbers, strings et cetera. But arrays are just object. Why we can create an array and then use the push method on it? Well, it's because of prototypal inheritance. Basically we create arrays from an array blueprint which is like a template and this is called the prototype. This prototype contains all the array methods and the arrays that we create in our code then inherit the methods from the blueprint.<br>

JavaScript is a language with first-class functions which simply means that functions are treated just as regular variables. We can pass them into other functions and return them from functions.<br>What is a concurrency model? Well it's just a fancy term that means how the JavaScript engine handles multiple tasks happening at the same time. Why do we need that? Because JavaScript itself runs in one single-thread,which means that it can only do one thing at a time and therefore we need a way of handling multiple things happening at the same time. In computing, a thread is like a set of instructions that is executed in the computer's CPU. Basically the thread is where our code is actually executed in a machine's processor. But what if there's a long-running task like fetching data from a remote server? Well, it sounds like that would block the single thread where the code is running. What we want is so-called non-blocking behavior and how do we achieve that? Well, by using a so-called event loop. The event loop takes long-running tasks, executed them in the background and then put them back in the main thread once they are finished. This is in a nutshell JavaScript's non-blocking event loop concurrency model with a single thread. 

