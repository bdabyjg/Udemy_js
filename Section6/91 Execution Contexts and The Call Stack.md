# 91 Execution Contexts and The Call Stack

The code is ready to be executed. What happens then is that a so-called global execution context is created for the top level code. Top level code is basically code that is not inside a function. In the beginning, only the code that's an outside of the functions would be executed. This makes sense. Functions only be executed when they are called.

What exactly is an execution context? Well, in a execution context is an abstract concept. But I define it basically as an environment in which a piece of JavaScript is executed. It's like a box stores all the necessary information for some code to be executed, such as local variables or arguments passed into a function. So JavaScript code always runs inside as an execution context. To make it a bit more intuitive, let's imagine you order a pizza at a take way. Usually the pizza comes in a box, and it might also come with some other stuff that's necessary for you to eat pizza such as cutlery or a receipt so that you can actually pay for the pizza before you eat it. So in this analogy, the pizza is the JavaScript code to be executed and the box is the execution context for the pizza. That's because the pizza happens inside the box which then the environment for eating pizza. The box also contains the cutlery and the receipt which are necessary to eat the pizza. In other words, to execute the code.

Now in any JavaScript project no matter how large is there's only ever one global execution context. It always there before contexts and top level code were executed. Speaking of execute, now that we have the environment where the top level code can be executed. It finally is executed. There is not a lot to say about the execution itself. It's just the computer's CPU processing the machine code that it received. Once this first code so the top-level of code is finished, functions finally start to execute as well. Here's how it works. For each and every function call, a new execution context will be created, containing all the information that is necessary to run exactly that function. The same goals for methods because they're simply functions attached to the objects. Anyway, all these execution contexts together make up the call stack that mention before. But more on that in a second. Now when all functions are done executing, the engine will basically keep waiting for callback functions to arrive so that can executed these. For example a callback function associated with a click event. That's the event loop who provides these new callback functions. We know now what an execution context is, but don't really know what it's made of. The first thing that's inside any execution context is so called variable environment. In this environment all our variables and function declarations are stored, and there's also special arguments object. This object contains as the name says all the arguments that were passed into the function that the current execution context belongs to. Because each function gets its own execution context as soon as the function is called. So basically the variables that are somehow declared inside the function were end up with its variable environment. However, a function can also access its variable outside the function. We have already seen that the action. This works because of something called the scope chain. The scope chain basically consists of references to variables that are located outside of the current function. To keep track of the scope train, it is stored in each execution context. Finally each also gets especial variable called "this" keyword. Now the content of the execution context -- variable environment, scope chain and "this" keyword is generated in a so-called creation phase which happens right before execution.

**The execution contexts belonging to arrow functions, do not get their own arguments keyword, nor do they get the "this" keyword. **Basically arrow functions don't have the arguments object and the "this" keyword. Instead, they can use the arguments object, and the "this" keyword from their closest regular function parent. Theses are the things that are necessary to run each function as well as the code in the top-level.

`const name = 'candela';`

`const first =()=>{`

  `let a = 1;`

  `const b = second(7,9);`

 ` a = a +b ;`

 ` return a;`

`}`

`function second(x,y){`

  `var c =2;`

  `return c;`

`}`

`const x = first();`

Behind the scenes, it's actually even more complex. Now let's actually try to simulate the creation phase for this code example here. We'll get one global execution context and one for each function. One for the first function and one for the second function. In the global context we have the name variable declaration, the first and second function declarations as well as the "X" variable declaration. For the functions, the variable environment will literally contain all the code of a particular function. The value of X is marked as unknown here because this value is the result of the first function that we didn't run yet. Technically none of these values actually become known during the creation phase, but only in the execution phase. Now in the first function, we have the "a" variable set to 1 and the "b" variable which once again requires a function call in order to become known. Finally the variable environment of the second function contains the "c" variable set to 2 and since this is a regular function, so not an arrow function, it also has the argument object. This object is an array which contain all the arguments that we passed into the function when they was called. In this case, as you can see, that 7and9. Imagine there are hundreds of execution contexts for hundreds of functions, how would the engine keep track of the order in which functions were called? And how would they where it currently is in the execution? Well, that's where the call stack finally comes in. Remember the call stack together with the memory heap makes up the JavaScript engine itself. But what actually is the call stack?

Call stack is basically a space where execution context gets stacked on top of each other, in order to keep track of where we are in the program execution. So that the execution context that is on top the stack is that the one is currently running. When it finished running it will be remove from the stack and the execution will go back to the previous context. Using the analogy from before, it is as if you bought pizzas with some friends. Each friend has a pizza box, and then you put the boxes on the top of each other forming the stack in order to keep track which pizza belongs each friend.

Once the code is compiled, top level code will start to execution. A global context will be created for the top level code. This is where all the code outside any function will be executed. What happens with this execution context? It will be put in the call stack. Since this context is now at the top of the stack, it is the one where the code is currently to being executed. Continue this execution. There is a simple variable declaration. Then the first, the second function were declared. That's just how normal code gets executed. In the last line we declared an "x" variable with the value that is gonna be returned from the calling of "first" function. Let's actually call the function. What happens immediately when a function is called? It gets its own execution context so that it can run the code that's inside its body. What happens in the context? Again, it is put in the call stack on the top of the current so it's now the new current execution context. So we have yet another simple variable declaration here, this variable will be defined in the variable environment of the current execution context and not in the global context. Then right in the next line we have another function call. Let's call that function and move there, a new execution context was created right away for this second function. Once more it is pushed on to the call stack becomes the new context. What's important to know here is that the execution of the first function has now been paused. So again, we are running the second function now and in the meantime no other function is been executed. The first function stopped at this point where the second function was called only continue as soon as this second function returns. It has to work this way because remember, JavaScript has only one thread of execution. So it can only do one thing at a time. Moving to the next line, we have a return statement meaning that the function will finish its execution. So what does that mean for the call stack? Well it basically means that the function's execution context, will be popped off the stack and disappear from the computer's memory. For now the popped off execution context might keep living in memory. The previous execution context will now be back to being the active execution context again. Without the call stack, how would the engine know which function was being executed before? It makes this process almost effortless. So I'd like to use the analogy of the call stack being like a map for the JavaScript engine. Because the call stack ensures that the order of execution never gets lost. So we returned from the second function, or back in the first function where we have this calculation, and then finally this first function also returns. Here the same as before happens. So the current execution context gets popped off the stack and the previous context is now the current context where code is executed. In this case we're back to the global execution context and the line of code where the first function was first called. So here, the return value is finally assigned to "x" and the execution is finished. Now the program will now actually stay in this state forever until it its eventually really finished. And that only happens like when we close the browser tab, or the browser window. Only when the program is really finished like this is when the global execution context is also popped off the stack. This is in a nutshell how the call stack works. It is more accurate to say that code runs inside of execution contexts that are in the stack. But the general point is that code runs in the call stack which is true.

