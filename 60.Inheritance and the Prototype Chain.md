##60.Inheritance and the Prototype Chain
So there's a saying in Javascript which says that "Everything is an Object." And while this is almost correct, it is not 100percent correct though. Because in Javascript, we have two big types of values, primitives and objects.<br>
Primitives are all the values that have one of the data types that we talked about in the intro lectures. So numbers, strings, booleans, undefined and null values, all of these are primitives, and everything else are objects. And that's why in Javascript we say that everything is an object. And in fact, even simple things like functions, arrays, or dates are all objects in Javascript, and that's because in Javascript objects are not just for storing a bunch of data like we have been doing, but for really complex things under the surface. So we have been using objects all along just without knowing it. So always remember that almost everything is an object in Javascript, because it's one of the fundamental things that makes Javascript so unique and different from other popular programming languages.<br>
Alright so now that we know how important objects are in Javascript, let's look at object-oriented programming. So, in very simple terms object-oriented programming makes heavy use of objects, properties and methods, and these objects interact with one another to form complex applications. We use objects to store data, structure our code and keep our code clean. So far, we have only created simple objects holding some data. Imagine something like a blueprint from which we can generate as many objects as we want, and we can do that in Javascript. And right here is an example of that. This is a special Person object that we can basically use as a blueprint to create a lot of Person objects. In other programming languages, this is many times called a class, but in Javascript we like to call it a  constructor or prototype. So based on the constructor, we can create as many instances as we want. So here we have Jane, Mark and John objects once again, but these were created from Person constructor. So they are effectively Person instances, and now their name, year of birth and job variables are defined, and they all have access to "calculateAge" method. So again, the constructor acts like a blueprint and is used to create instances, which of course are also objects. We will do all of this with code over the next lectures.<br>
Now let's take this even one step further, with inheritance. In simple terms, inheritance is when one object is based on another object. It's when one object gets access to another object's properties and methods. Back to our person example, imagine that you also wanted to have an athlete constructor besides the person constructor, with a couple of different properties and methods. Now an athlete is also a person, right? There are some particular properties and methods for an athlete, like for example how many participations in Olympics they have or how many medals they have won. So when we define the blueprint, so the constructor for an athlete, they when repeat the same stuff that we have in our person constructor? An athlete also has a name, year of birth and job. So what we can do is to use inheritance. We make the athlete object inherit the properites and methods from the person object, so then the athlete not only has access to its own properties and methods but also the ones from the person object. This allows us to write less code and make more logical programs. So this is a broad overview of how inheritance works in theory. In all programming languages that have object-oriented futures. So let's see how Javascript in particular handles inheritance with our person and John examples.<br>
Javascript is a prototype-based language, which means that inheritance works by using something called prototypes. In practice, it means that each and every Javascript object has a prototype properity which makes inheritance possible in Javascript. So again, inheritance is made possible through the prototype property that every object has. Now all of this may look a bit confusing at first sight.<br>
Now, how does inheritance actually work? To better understand this, let's go back to our person example where the person object is the constructor and John is one of the inheritances. Now if we want John to inherit a method or a property from the person object, we have to add that method or property to the person's prototype property. So in this example, we have the calculateAge method in the person's prototype property and therefore John inherits the method and can then call it. And any other object created by the person constructor would inherit this method as well. So, again, the prototype property of an object is where we put methods and properties that we want other objects to inherit. What is really important to note here is that the person prototype is not the prototype of the person itself, but all of the instances that I created through the person blueprint, like John. So in other words, the person's prototype property is the prototype of John. That's not even all, because the person object itself is an instance of an even bigger constructor, which is the Object object. Each and every object that we ever create is an instance of the object constructor which has a bunch of methods in its prototype property. The person objcet inherit these methods and can call them. Plus, the John object also inherits these methods and can also use them. With that, we have actually explained the prototype chain.<br>
So the prototype chain is what makes all this inheritance possible, and here is how it works. When we try to access a certain method, or property on an object, Javascript will first try to find that method on the exact object. But if it cannot find it, it will look in the object's prototype, which is the prototype property of its parent. So it moves up in the prototype chain. If the method is sitll not there, this continues until there is no more prototype to look at, which is null. Null is the only one that has no prototype, and is therefore the final link in the prototype chain. In this case, undefined is returned. This is reason why the jonh object could call the hasOwnProperty method that is stored in the object prototype property. <br>
Summary:
- Every Javascript object has a prototype property, which makes inheritance possible in Javascript;
- The prototype property of an object is where we put methods and properties that we want other objects to inherit;
- The constructor's prototype property is NOT the prototype of the constructor itself, it's the prototype of ALL instances that are created through it;
- When a certain method (or a property) is called, the search starts in the object itself, and if it cannot be found, the search moves on to the object's prototype. This continues until the method is found:prototype chain.