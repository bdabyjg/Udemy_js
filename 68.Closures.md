## Closrues

We can summarize how a closure works like this:<br>
**An inner function has always access to the variables and parameters of its outer function, even after the outer function has returned.** As we already knew the new function gets a new execution context that is put on top of the execution stack. That execution context has an object, which stores the variables. The scope chain ended this variable. So let's see the scope chain for the retirement function, which means the variables that the function has access to. And remember the scope chain is like a pointer to all the variable objects that the function has access to. Alright , so of course, the function has access to the retirementAge argument,set to 66, and a variable that holds our string. Then the function returns. So after the function returns, now the execution context of the retirement function is effectively gone, and with it, the variable object and the entire scope chain should be gone. Actually, no. The secret to closures is that even after a function returns, and execution context is gone, the variable object is still there. It's not gone. It still sits here in memory and it can be accessed, and that's why we still it there in the execution stack on the left side, and also in the scope chain on the right side, because the scope chain is in fact a pointer to variable objects, and in this case, the variable object that we have here on the stack.<br>
So let's see this in action. Let's call the inner function that we effectively called "retirementUS" with the argument "1990", which puts a new execution context on the stack. Let's now look at the scope chain. So since this inner function is written lexically in the retirement function, it has access to its scope. Since the variable object of the retirement function is still there, the scope chain stays intact. It keeps working. And so we can access the variables that were created in the retirement function long after the function has completed execution, and after its execution is gone. The current execution context has closed in on the outer variable object, so that it can use it, and that's why it's called a closure. So the scope chain always stays intact. Just to finish this, the function simply returns, and the context is popped off the stack, as usual. Note that we don't create closures manually.<br>
(解释interviewQuestion那段代码的原理)：<br>
So let me explain it one last time.  So this function( **interviewQuestion('teacher')**) call here will return this function( **function(name)**) here. And then we call this function with the John parameter, the John argument, and then this execution context will close in over the variable object of the function that we had before, that we called before. So it will close in on the variables that we defined in the old function, which was the job variable, and so we can use this variable right into this function as well, and we do that in here. So here, in our if/else statement, we use the job variable of the interviewQuestion function that has already returned by the point that we use this inner function here. 