## 40. Scoping and the Scope Chain
  So in this scope we have access the variable "a" and also to the first function. In orange, we have the scope of the first function which defines the variable "b" and the second function, and this is the local scope, not a global scope. And do you remember what I said about lexical scoping in the last slide? Thanks to lexical scope, this scope has also access to its parent's scope and all the variables functions that it defines. And in this case, that's global scope. Finally, in the green, the scope of the second function. In there we have a "console.log" statement which attemps to print the values of variable "a","b" and "c". <br>
  Now, the variables are not defined in that function. Only "c", but as we already know, a scope has access to the scope of the function in which is sits lexically, so we running this code, the JavaScript engine will not find variable "b" in the current scope. So it just goes up and looks in the scope of its parent's function and says "oh, here is b. So let's use that." And the same happens for variable "a". It does not find it in the current scope and also not in the parent scope. So it goes even more up all the way to the global scope and this is excatly called the "scope chain". Only if the JavaScript engine does not find a variable anywhere it throws an error and stops execution.<br>
  Now, it's very important to note that this does not work backwards. For example, the global scope will never ever have accessed to the variables "b" or "c" unless we return the values from the functions. So locally scoped variables are not visible to their parent's scopes. This is why I put the red arrow pointing upwards. Because that's the only direction the scope chain works.<br>
  Now how does this actually work behind the scenes? Remember the execution context object that we had been talking about before? In the creation phase, each execution context object will get exact scope chain which is basically all the variable objects that an execution context has access to. Because, remember the variable object is what stores all the defined variables and functions. So in this example, in the second scope, we have access to the variable object of the second functions, of the first function and to global variable object.<br>
  So why does this work? This works because, of course, the scoping chain and in this case thanks to the scoping chain,the second function has access to the variables of the first function and of the global scope. That's because the second function is written inside of the first, which in turn, is written inside of the global scope. That's why we call it lexcial scoping. So another extremely important concept and very much used in practice as well.<br>
  <br>
  ...So we saw it at the scope chain for each execution context is stored in the execution context object. But I just wanted to make very clear that the execution stack is different from scope chain. So here we see another simple code example, and we already know how the execution stack works. So the first function gets called, which then calls the second function which in turn calls the third function and for each of these calls, a new execution context is put on top the execution stack. Now, for the scope chain, things are a bit different. We see that the global scope contains the "a" variable as well as the first and third functions. Then the scope of the first function contains the second function, and this is how I like to represent it. Now let's remember that the execution stack is the order in which functions are called. But the scope chain is the order in which the functions are written in the code where they are lexically in our code. So the order in which functions are called does not determine the scope of the variables within these functions. What determines the scope of variables is where the functions are written. Since the third function is not in the scope of the second function, of course it cannot access variables "b" and "c" defined in the second and first functions. It can only access the global variable "a", because the function is written in the global scope.